<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Sliding Window 滑动窗口 | WeiKnight's Personnal Blogs</title><link rel="icon" href="https://avatars.githubusercontent.com/WeiKnight0"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&amp;family=Roboto:wght@400;500;700&amp;display=swap"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"><link rel="stylesheet" href="/css/note.css"><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><!-- 导航栏--><header class="navbar"><div class="navbar-container"><div class="navbar-brand"><a class="avatar-link" target="_blank" rel="noopener" href="https://github.com/WeiKnight0"><img class="avatar" src="https://avatars.githubusercontent.com/WeiKnight0" alt="WeiKnight"></a><div class="navbar-info"><a class="name" target="_blank" rel="noopener" href="https://github.com/WeiKnight0">WeiKnight</a><div class="subject">Study Notes</div></div></div><div class="navbar-actions"><a class="nav-link" href="../" title="Return to Misc"><i class="fas fa-arrow-left"></i><span>Return to Misc</span></a><a class="nav-link" href="/"><i class="fas fa-home"></i><span>Return to Home Page</span></a></div></div></header><!-- 标题区域--><section class="title-section"><div class="title-container"><h1 class="chapter-title">Sliding Window 滑动窗口</h1><div class="chapter-meta"><span class="chapter-date"><i class="far fa-calendar-alt"></i>2026-02-04</span><span class="chapter-lang"><p>Language: 简体中文</p></span></div></div></section><!-- 内容区域--><main class="content-section"><article class="chapter-content"><h1 id="sliding-window-滑动窗口">Sliding Window 滑动窗口</h1>
<p>滑动窗口是一种用于处理数组或字符串中连续子集问题的算法技术。它通过维护一个“窗口”在数据结构上滑动，以高效地计算所需的结果，而不需要重复计算。</p>
<h2 id="定长滑动窗口">定长滑动窗口</h2>
<p>要计算长度恰好为 k 的子串中的某个属性（如和、最大值等），可以使用定长滑动窗口。</p>
<p>三步法：</p>
<ol>
<li><strong>入</strong>：下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的元素进入窗口，更新相关统计量。如果窗口左端点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mtext>−</mtext><mi>k</mi><mo>+</mo><mn>1</mn><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i−k+1&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则尚未形成第一个窗口，重复第一步。</li>
<li><strong>更新</strong>：若尚未形成窗口，则继续等待；当窗口形成后，更新结果。</li>
<li><strong>出</strong>：下标为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mtext>−</mtext><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i−k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的元素离开窗口，更新相关统计量。</li>
</ol>
<p>例：<br>
给你字符串 s 和整数 k 。</p>
<p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p>
<p>英文中的 元音字母 为（a, e, i, o, u）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>,cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; l; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;a&#x27;</span>||s[i]==<span class="string">&#x27;e&#x27;</span>||s[i]==<span class="string">&#x27;i&#x27;</span>||s[i]==<span class="string">&#x27;o&#x27;</span>||s[i]==<span class="string">&#x27;u&#x27;</span>)&#123;</span><br><span class="line">                cur++; <span class="comment">// 入</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i - k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(left &lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 尚未形成窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur); <span class="comment">// 更新结果</span></span><br><span class="line">            <span class="type">char</span> out = s[left];</span><br><span class="line">            <span class="keyword">if</span>(out == <span class="string">&#x27;a&#x27;</span>||out == <span class="string">&#x27;e&#x27;</span>||out == <span class="string">&#x27;i&#x27;</span>||out == <span class="string">&#x27;o&#x27;</span>||out == <span class="string">&#x27;u&#x27;</span>)&#123;</span><br><span class="line">                cur--; <span class="comment">// 出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="不定长滑动窗口">不定长滑动窗口</h2>
<p>由于区间长度不定，因此需要使用双指针来维护窗口的左右边界。定义一个 <code>left</code> 变量，在遍历过程中不断移动 <code>right</code> 指针扩大窗口，同时根据条件移动 <code>left</code> 指针缩小窗口。</p>
<p>此时，“出” 可能先于 “更新”。</p>
<h3 id="越短越合法-求最长-最大">越短越合法/求最长/最大</h3>
<p>当窗口满足条件时，尝试缩小窗口以找到更短的合法窗口；当窗口不满足条件时，扩大窗口以寻找合法窗口。</p>
<p>例题：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的最长子串的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;<span class="comment">//[left,i]</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">            mp[s[i]] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(mp[s[i]] &gt; <span class="number">1</span> &amp;&amp; left &lt;= i)&#123;</span><br><span class="line">                mp[s[left]]--; <span class="comment">// 这里要先更新，再移动 left 指针，要根据具体题目来决定先更新还是先移动</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="越长越合法-求最短-最小">越长越合法/求最短/最小</h3>
<p>使用的方法是：外循环右端点扩展窗口，内循环左端点缩小窗口。每当窗口满足条件时，尝试缩小窗口以找到更长的合法窗口；当窗口不满足条件时，扩大窗口以寻找合法窗口。</p>
<p>例：最短且字典序最小的美丽子字符串</p>
<p>给你一个二进制字符串 s 和一个正整数 k 。<br>
如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。<br>
令 len 等于 最短 美丽子字符串的长度。<br>
返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。<br>
对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。<br>
例如，&quot;abcd&quot; 的字典序大于 &quot;abcc&quot; ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shortestBeautifulSubstring</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ranges::<span class="built_in">count</span>(s, <span class="string">&#x27;1&#x27;</span>) &lt; k)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string ans = s;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; k || s[left] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 出</span></span><br><span class="line">                <span class="keyword">if</span> (s[left] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    cnt--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">                string t = s.<span class="built_in">substr</span>(left, i - left + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (t.<span class="built_in">size</span>() &lt; ans.<span class="built_in">size</span>() ||</span><br><span class="line">                    (t.<span class="built_in">size</span>() == ans.<span class="built_in">size</span>() &amp;&amp; t &lt; ans)) &#123;</span><br><span class="line">                    ans = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="求子数组个数">求子数组个数</h2>
<h3 id="越短越合法">越短越合法</h3>
<p>一般要写 <code>ans += right - left + 1</code>。</p>
<p>内层循环结束后，<code>[left,right]</code> 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 <code>[left,right]</code>，还有 <code>[left+1,right],[left+2,right],…,[right,right]</code> 都是满足要求的。也就是说，当右端点固定在 <code>right</code> 时，左端点在 <code>left,left+1,left+2,…,right</code> 的所有子数组都是满足要求的，这一共有 <code>right−left+1</code> 个。</p>
<p>例：[<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">https://leetcode.cn/problems/subarray-product-less-than-k/description/</a>](713. 乘积小于 K 的子数组)<br>
给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll cur = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, left = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cur *= nums[i];</span><br><span class="line">            <span class="keyword">while</span> (cur &gt;= k) &#123;</span><br><span class="line">                cur /= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt += i - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="越长越合法">越长越合法</h3>
<p>一般要写 <code>ans += left</code>。</p>
<p>内层循环结束后，<code>[left,right]</code> 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，<code>[left−1,right]</code> 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 <code>[left−1,right]</code>，还有 <code>[left−2,right]</code>、<code>[left−3,right]</code>、…、<code>[0,right]</code> 都是满足要求的。也就是说，当右端点固定在 <code>right</code> 时，左端点在 <code>0,1,2,…,left−1</code> 的所有子数组都是满足要求的，这一共有 <code>left</code> 个。</p>
<p>我们关注的是 <code>left−1</code> 的合法性，而不是 <code>left</code>。</p>
<p>例：[<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/description/">https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/description/</a>](1358. 包含所有三种字符的子字符串数目)<br>
给你一个字符串 s ，它只包含三种字符 a, b 和 c 。</p>
<p>请你返回 a，b 和 c 都 至少 出现过一次的子字符串数目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">3</span>]&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">while</span> (cnt[<span class="number">0</span>] &amp;&amp; cnt[<span class="number">1</span>] &amp;&amp; cnt[<span class="number">2</span>]) &#123;</span><br><span class="line">                cnt[s[left] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="恰好型滑动窗口">恰好型滑动窗口</h3>
<p>例如，要计算有多少个元素和恰好等于 k 的子数组，可以把问题变成：</p>
<p>计算有多少个元素和 ≥k 的子数组。<br>
计算有多少个元素和 &gt;k，也就是 ≥k+1 的子数组。<br>
答案就是元素和 ≥k 的子数组个数，减去元素和 ≥k+1 的子数组个数。这里把 &gt; 转换成 ≥，从而可以把滑窗逻辑封装成一个函数 solve，然后用 solve(k)−solve(k+1) 计算，无需编写两份滑窗代码。</p>
<p>总结：「恰好」可以拆分成两个「至少」，也就是两个「越长越合法」的滑窗问题。</p>
<p>注：也可以把问题变成 ≤k 减去 ≤k−1，即两个「至多」。可根据题目选择合适的变形方式。</p>
<p>注：也可以把两个滑动窗口合并起来，维护同一个右端点 right 和两个左端点 left1 和 left2 ，这种写法叫做三指针滑动窗口。</p>
</article><!-- 笔记工具条--><div class="note-tools"><button class="tool-btn" id="toggle-dark"><i class="fas fa-moon"></i><span>Dark Mode</span></button><button class="tool-btn" id="print-note"><i class="fas fa-print"></i><span>Print This Note</span></button></div></main><!-- 页脚--><footer class="footer"><div class="footer-content"><p>© 2025 WeiKnight. All Rights Reserved. </p><div class="footer-links"><a href="/notes/about" target="_blank">About</a><a href="/notes/terms" target="_blank">Terms of Use</a><a href="/notes/privacy" target="_blank">Privacy Policy</a></div></div></footer><script src="/js/note.js"></script><script>document.querySelectorAll('figure.highlight').forEach((figure) => {
  const langClass = Array.from(figure.classList).find(cls => cls !== 'highlight');
  if (!langClass) return;

  const langLabel = document.createElement('div');
  langLabel.textContent = langClass;
  langLabel.style.position = 'absolute';
  langLabel.style.top = '0';
  langLabel.style.right = '0';
  langLabel.style.padding = '0.2em 0.5em';
  langLabel.style.fontFamily = 'MapleMono-NF-CN';
  langLabel.style.fontSize = '0.8em';
  langLabel.style.borderRadius = '0 4px 0 4px';
  langLabel.style.zIndex = '1';

  // 设置初始样式（根据当前主题）
  updateLabelTheme(langLabel);

  figure.style.position = 'relative';
  figure.prepend(langLabel);
});

// 更新标签主题的函数
function updateLabelTheme(label) {
  const isDarkMode = document.body.getAttribute('data-theme') === 'dark';
  label.style.background = isDarkMode ? '#444' : '#eee';
  label.style.color = isDarkMode ? '#ddd' : '#333';
  //- console.log("更改了");
}

// 监听主题变化（仅更新标签）
new MutationObserver(() => {
  document.querySelectorAll('figure.highlight div').forEach(label => {
    updateLabelTheme(label);
    //- console.log("更改了2");
  });
}).observe(document.body, {
  attributes: true,
  attributeFilter: ['data-theme']
});</script></body></html>