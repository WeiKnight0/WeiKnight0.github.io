<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Chapter 4: Threads | WeiKnight's Personnal Blogs</title><link rel="icon" href="https://avatars.githubusercontent.com/WeiKnight0"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&amp;family=Roboto:wght@400;500;700&amp;display=swap"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"><link rel="stylesheet" href="/css/note.css"><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><!-- 导航栏--><header class="navbar"><div class="navbar-container"><div class="navbar-brand"><a class="avatar-link" target="_blank" rel="noopener" href="https://github.com/WeiKnight0"><img class="avatar" src="https://avatars.githubusercontent.com/WeiKnight0" alt="WeiKnight"></a><div class="navbar-info"><a class="name" target="_blank" rel="noopener" href="https://github.com/WeiKnight0">WeiKnight</a><div class="subject">Study Notes</div></div></div><div class="navbar-actions"><a class="nav-link" href="../" title="Return to Operating System"><i class="fas fa-arrow-left"></i><span>Return to Operating System</span></a><a class="nav-link" href="/"><i class="fas fa-home"></i><span>Return to Home Page</span></a></div></div></header><!-- 标题区域--><section class="title-section"><div class="title-container"><h1 class="chapter-title">Chapter 4: Threads</h1><div class="chapter-meta"><span class="chapter-date"><i class="far fa-calendar-alt"></i>2025-07-24</span><span class="chapter-lang"><p>Language: English</p></span></div></div></section><!-- 内容区域--><main class="content-section"><article class="chapter-content"><hr>
<h2 id="目录-contents">目录 (Contents)</h2>
<ol>
<li>Warm-up​</li>
<li>Overview​</li>
<li>Multicore Programming​</li>
<li>Multithreading Models​</li>
<li>Thread Libraries</li>
<li>Implicit Threading​</li>
<li>Threading Issues</li>
</ol>
<hr>
<h2 id="1-warm-up">1. Warm-up</h2>
<h3 id="线程抽象的必要性-why-threads">线程抽象的必要性 (Why Threads?)</h3>
<ul>
<li><strong>Motivation</strong>:
<ul>
<li>程序可能需要多个执行点（如多个程序计数器PC）。</li>
<li><strong>Example 1</strong>: 加速大型数组相加。</li>
<li><strong>Example 2</strong>: 部分任务需等待输入时，其他任务可继续执行。</li>
</ul>
</li>
<li><strong>Threads vs Processes</strong>:
<ul>
<li>线程更轻量，共享同一进程的资源（如内存、文件），创建和切换开销更低。</li>
</ul>
</li>
</ul>
<h3 id="核心问题-key-questions">核心问题 (Key Questions)</h3>
<ul>
<li>为什么需要线程而非多进程？
<ul>
<li>线程共享进程资源，通信成本低；进程独立，切换开销大。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-overview">2. Overview</h2>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>进程 (Process)</strong></th>
<th><strong>线程 (Thread)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定义</strong></td>
<td>操作系统资源分配的基本单位，拥有独立的内存空间</td>
<td>进程内的执行单元，共享进程资源（内存、文件等）</td>
</tr>
<tr>
<td><strong>独立性</strong></td>
<td>完全隔离，一个进程崩溃不影响其他进程</td>
<td>共享进程内存，线程崩溃可能导致整个进程崩溃</td>
</tr>
<tr>
<td><strong>资源开销</strong></td>
<td>高（独立内存、文件描述符等）</td>
<td>低（共享进程资源，仅需独立栈和寄存器）</td>
</tr>
<tr>
<td><strong>创建/切换成本</strong></td>
<td>高（需操作系统介入，上下文切换复杂）</td>
<td>低（用户态可调度，上下文切换快）</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>进程间通信（IPC）：管道、消息队列、共享内存、Socket 等</td>
<td>直接读写共享内存（需同步机制如互斥锁、信号量）</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>多进程可并行运行（利用多核 CPU）</td>
<td>多线程可并发执行（单核 CPU 通过时间片切换，多核可真正并行）</td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>需要高稳定性/隔离性的任务（如浏览器多标签页、QQ 主程序与安全模块）</td>
<td>需要高效协作的任务（如聊天软件的消息处理、UI 渲染与网络请求分离）</td>
</tr>
<tr>
<td><strong>系统管理</strong></td>
<td>由操作系统直接调度</td>
<td>由进程内的线程库（如 pthread）管理，操作系统感知为“轻量级进程”（LWP）</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>同时运行的 QQ 和 Chrome 是两个独立进程</td>
<td>QQ 主进程内的消息收发线程和文件传输线程</td>
</tr>
</tbody>
</table>
<h3 id="多线程应用场景-multithreading-applications">多线程应用场景 (Multithreading Applications)</h3>
<ul>
<li><strong>Examples</strong>:
<ul>
<li>文字处理器：同时处理显示更新、数据获取、拼写检查。</li>
<li>多线程RPC服务器：并发处理请求。</li>
<li>操作系统内核：多线程设计提高效率。</li>
</ul>
</li>
</ul>
<h3 id="单线程-vs-多线程进程-single-vs-multi-threaded-processes">单线程 vs 多线程进程 (Single vs Multi-threaded Processes)</h3>
<ul>
<li><strong>Single-threaded</strong>:
<ul>
<li>包含代码、数据、文件和单一线程（寄存器+栈）。</li>
</ul>
</li>
<li><strong>Multi-threaded</strong>:
<ul>
<li>同一进程内多个线程共享代码、数据、文件，但各有独立的寄存器和栈。</li>
<li><strong>code, data, files: 共享；registers, stack: 独享</strong><br>
<img src="./pictures/4-1.png" alt="Multithreaded"></li>
</ul>
</li>
</ul>
<h3 id="多线程优势-benefits">多线程优势 (Benefits)</h3>
<table>
<thead>
<tr>
<th><strong>Advantage</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Responsiveness</strong></td>
<td>部分线程阻塞时，其他线程仍可运行（如UI线程）。<br />may allow continued execution if part of process is blocked, especially important for user interfaces</td>
</tr>
<tr>
<td><strong>Resource Sharing</strong></td>
<td>线程共享进程资源，无需IPC（共享内存/消息传递）。<br />threads share resources of process, easier than shared memory or message passing</td>
</tr>
<tr>
<td><strong>Economy</strong></td>
<td>创建线程比进程更快，上下文切换开销更低。<br />cheaper than process creation, thread switching lower overhead than context switching</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>多核架构下，线程可并行执行。<br />process can take advantage of multiprocessor architectures</td>
</tr>
</tbody>
</table>
<h3 id="多线程分类-multithreading-models">多线程分类 (Multithreading Models)</h3>
<ul>
<li><strong>四种模式</strong>:
<ol>
<li>单进程单线程（如MS-DOS）。</li>
<li>单进程多线程（如Java运行时环境）。</li>
<li>多进程单线程（传统UNIX）。</li>
<li>多进程多线程（现代OS主流）。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="3-multicore-programming">3. Multicore Programming</h2>
<h3 id="并行-parallelism-与并发-concurrency">并行 Parallelism 与并发 Concurrency</h3>
<ul>
<li><strong>Concurrency</strong>: 单核上通过调度实现多任务“同时”推进（时间片轮转）。</li>
<li><strong>Parallelism</strong>: 多核上真正同时执行多任务。</li>
</ul>
<h3 id="并行类型-types-of-parallelism">并行类型 (Types of Parallelism)</h3>
<ul>
<li><strong>Data Parallelism</strong>: 数据分片，各核心对不同数据执行相同操作。 distributes subsets of the same data across multiple cores, same operation on each</li>
<li><strong>Task Parallelism</strong>: 不同线程执行不同任务。  distributing threads across cores, each thread performing unique operation</li>
</ul>
<h3 id="amdahl-s-law-阿姆达尔定律">Amdahl's Law (阿姆达尔定律)</h3>
<ul>
<li>
<p>Identifies performance gains from adding additional cores to an application that has both serial and parallel components</p>
</li>
<li>
<p>对于既有串行也有并行组件的应用程序，该公式确定由于计算核的增加而得到的性能改进。</p>
</li>
<li>
<p><strong>公式</strong>:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>speedup</mtext><mo>≤</mo><mfrac><mn>1</mn><mrow><mi>S</mi><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><mi>N</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{speedup} \leq \frac{1}{S + \frac{(1-S)}{N}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">speedup</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.56644em;vertical-align:-1.245em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.1099999999999994em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.2399999999999998em;"><span class="pstrut" style="height:3.01em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.687em;"><span class="pstrut" style="height:3.01em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.245em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> : 串行部分比例，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>: 核心数。</li>
</ul>
</li>
<li>
<p><strong>关键结论</strong>:</p>
<ul>
<li>串行部分限制多核加速潜力（如25%串行 → 最大加速比4倍）。</li>
<li>Serial portion of an application has disproportionate effect on performance gained by adding additional cores</li>
<li>应用程序的串行部分对通过增加额外内核所获得的性能提升有着不成比例的影响。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-multithreading-models">4. Multithreading Models</h2>
<h3 id="用户线程-vs-内核线程-user-vs-kernel-threads">用户线程 vs 内核线程 (User vs Kernel Threads)</h3>
<table>
<thead>
<tr>
<th><strong>Type</strong></th>
<th><strong>Managed By</strong></th>
<th><strong>Pros</strong></th>
<th><strong>Cons</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User Threads</strong></td>
<td>用户态线程库（如Pthreads）</td>
<td>无内核干预，高效。</td>
<td>一个线程阻塞会导致整个进程阻塞。</td>
</tr>
<tr>
<td><strong>Kernel Threads</strong></td>
<td>操作系统内核</td>
<td>阻塞线程不影响其他线程；支持多核。</td>
<td>创建和切换开销较大。</td>
</tr>
</tbody>
</table>
<p><img src="./pictures/4-2.png" alt="Multithreading Models"></p>
<p><img src="./pictures/4-3.png" alt="4-3"></p>
<h3 id="多线程模型-threading-models">多线程模型 (Threading Models)</h3>
<ol>
<li><strong>Many-to-One</strong>:
<ul>
<li>多用户线程映射到单内核线程（已淘汰）。</li>
<li><img src="pictures/4-7.png" alt=""></li>
</ul>
</li>
<li><strong>One-to-One</strong>:
<ul>
<li>每个用户线程对应一个内核线程（如Windows/Linux的NPTL）。</li>
<li><img src="pictures/4-8.png" alt=""></li>
</ul>
</li>
<li><strong>Many-to-Many</strong>:
<ul>
<li>动态映射用户线程到内核线程（平衡并发与效率）。</li>
<li><img src="pictures/4-9.png" alt=""></li>
</ul>
</li>
<li><strong>Two-Level Model</strong>:
<ul>
<li>类似M:M，但允许绑定部分用户线程到内核线程。</li>
<li><img src="pictures/4-10.png" alt=""></li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-thread-libraries">5. Thread Libraries</h2>
<h3 id="主流线程库-thread-libraries">主流线程库 (Thread Libraries)</h3>
<ul>
<li><strong>Pthreads</strong>: POSIX标准，跨平台（用户/内核态实现）。<br>
<strong>1. <code>pthread_create</code> - 创建线程</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_t</span> *thread,          <span class="comment">// 线程标识符指针</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="comment">// 线程属性（可NULL）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="comment">// 线程入口函数</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *arg                  <span class="comment">// 传递给入口函数的参数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明："><strong>参数说明：</strong></h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>thread</code></strong></td>
<td><code>pthread_t *</code></td>
<td>输出参数，返回新线程的标识符（用于后续操作如<code>pthread_join</code>）。</td>
</tr>
<tr>
<td><strong><code>attr</code></strong></td>
<td><code>const pthread_attr_t *</code></td>
<td>线程属性（栈大小、调度策略等），通常传<code>NULL</code>表示默认属性。</td>
</tr>
<tr>
<td><strong><code>start_routine</code></strong></td>
<td><code>void *(*)(void *)</code></td>
<td>线程入口函数指针，函数格式必须为<code>void* func(void* args)</code>。</td>
</tr>
<tr>
<td><strong><code>arg</code></strong></td>
<td><code>void *</code></td>
<td>传递给<code>start_routine</code>的参数（需强制转换为<code>void*</code>，在线程内再转回实际类型）。</td>
</tr>
</tbody>
</table>
<h4 id="返回值："><strong>返回值：</strong></h4>
<ul>
<li>成功返回 <code>0</code>，失败返回错误码（非<code>errno</code>，需用<code>strerror</code>解析）。</li>
</ul>
<h3 id="2-pthread-join-等待线程结束"><strong>2. <code>pthread_join</code> - 等待线程结束</strong></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">pthread_t</span> thread,     <span class="comment">// 要等待的线程标识符</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> **value_ptr      <span class="comment">// 接收线程返回值（可NULL）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数说明："><strong>参数说明：</strong></h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>thread</code></strong></td>
<td><code>pthread_t</code></td>
<td>要等待的线程标识符（由<code>pthread_create</code>返回）。</td>
</tr>
<tr>
<td><strong><code>value_ptr</code></strong></td>
<td><code>void **</code></td>
<td>输出参数，接收线程入口函数的返回值（若不需要可传<code>NULL</code>）。</td>
</tr>
</tbody>
</table>
<p>注意：void* ret == *value_ptr的指向会被pthread改变</p>
<h4 id="返回值："><strong>返回值：</strong></h4>
<ul>
<li>成功返回 <code>0</code>，失败返回错误码。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">thread_task</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *result = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)result; <span class="comment">// 返回动态分配的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_task, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *ret_val;</span><br><span class="line">    pthread_join(tid, &amp;ret_val); <span class="comment">// 等待线程并获取返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned: %d\n&quot;</span>, *(<span class="type">int</span> *)ret_val);</span><br><span class="line">    <span class="built_in">free</span>(ret_val); <span class="comment">// 释放线程返回的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例1</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myarg_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; <span class="type">myarg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">myarg_t</span> *m = (<span class="type">myarg_t</span> *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, m-&gt;a, m-&gt;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">myarg_t</span> args;</span><br><span class="line">    args.a = <span class="number">10</span>;</span><br><span class="line">    args.b = <span class="number">20</span>;</span><br><span class="line">    rc = pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line">    <span class="comment">// ... (rest of the code, e.g., pthread_join)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tempindata = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myarg_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125; <span class="type">myarg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myrett_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; <span class="type">myrett_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addr. of &amp;arg (in mythread): %p\n&quot;</span>, &amp;arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addr. of arg (in mythread): %p\n&quot;</span>, arg);</span><br><span class="line">    <span class="type">int</span> tempinthread = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addr. of tempinthread: %p\n&quot;</span>, &amp;tempinthread);</span><br><span class="line">    </span><br><span class="line">    <span class="type">myarg_t</span> *m = (<span class="type">myarg_t</span> *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, m-&gt;a, m-&gt;b);</span><br><span class="line">    </span><br><span class="line">    <span class="type">myrett_t</span> *r = (<span class="type">myrett_t</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">myrett_t</span>));</span><br><span class="line">    r-&gt;x = <span class="number">1</span>;</span><br><span class="line">    r-&gt;y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> tempinstack = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *tempinheap = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *tempinheap = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addr. of tempindata: %p\n&quot;</span>, &amp;tempindata);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addr. of tempinstack: %p\n&quot;</span>, &amp;tempinstack);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addr. of tempinheap: %p\n&quot;</span>, tempinheap);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="type">myrett_t</span> *m;</span><br><span class="line">    <span class="type">myarg_t</span> args;</span><br><span class="line">    args.a = <span class="number">10</span>;</span><br><span class="line">    args.b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Addr. of &amp;args (in main): %p\n&quot;</span>, &amp;args);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line">    pthread_join(p, (<span class="type">void</span> **) &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;returned %d %d\n&quot;</span>, m-&gt;x, m-&gt;y);</span><br><span class="line">    <span class="built_in">free</span>(m);</span><br><span class="line">    <span class="built_in">free</span>(tempinheap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	输出：</p>
<p><img src="./pictures/4-4.png" alt="4-4"></p>
<ul>
<li>
<p><strong>Windows Threads</strong>: 内核级API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Summation, &amp;Param, <span class="number">0</span>, &amp;ThreadId);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Java Threads</strong>: 通过JVM实现，底层依赖OS线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Summation</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* 线程逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="in-class-exercise">In Class Exercise</h3>
<p>What are the outputs?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kai.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">helloFunc</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    data = (<span class="type">int</span> *)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m Thread %d\n&quot;</span>, *data);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> hThread[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> *rvals[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;hThread[i], <span class="literal">NULL</span>, helloFunc, (<span class="type">void</span> *)&amp;i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        pthread_join(hThread[i], (<span class="type">void</span> **)&amp;rvals[i]);</span><br><span class="line">        <span class="comment">// printf(&quot;Thread %d returns %d\n&quot;, i, *rvals[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o kai kai.c -pthread -Wall</span><br><span class="line">./kai</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong></p>
<p><img src="./pictures/4-5.png" alt="kai.cc"></p>
<h4 id="问题所在"><strong>问题所在</strong></h4>
<ul>
<li><strong>数据竞争（Race Condition）</strong>：
<ul>
<li>所有线程共享主线程的局部变量 <code>i</code> 的地址（<code>&amp;i</code>）。</li>
<li>主线程的 <code>for</code> 循环会快速修改 <code>i</code> 的值（从<code>0</code>递增到<code>4</code>），而子线程可能在 <code>i</code> 被修改后才读取它。</li>
<li>最终可能导致多个线程打印相同的 <code>i</code> 值，甚至越界（如<code>i=4</code>）。</li>
</ul>
</li>
<li>因此一切非降的序列都是对的
<ul>
<li>因为主线程对<code>i</code>的改变只有增加</li>
</ul>
</li>
</ul>
<p><strong>More details</strong><br>
更合理的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">helloFunc</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    data = (<span class="type">int</span> *)ptr;<span class="comment">// 内存泄露！</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m Thread %d\n&quot;</span>, *data);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> hThread[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> pvals[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        pvals[j] = j;</span><br><span class="line">    <span class="comment">// 为每个线程单独分配一个参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        pthread_create(&amp;hThread[i], <span class="literal">NULL</span>, helloFunc, (<span class="type">void</span> *)&amp;pvals[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *rvals[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        rvals[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        pthread_join(hThread[i], (<span class="type">void</span> **)&amp;rvals[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %d returns %d\n&quot;</span>, i, *rvals[i]);</span><br><span class="line">        <span class="comment">// free(rvals[i]); // Segmentation fault with this line</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是会出现内存泄露问题</p>
<h3 id="常见问题-common-issues">常见问题 (Common Issues)</h3>
<ul>
<li><strong>线程安全</strong>: 共享数据需同步（如互斥锁）。</li>
<li><strong>内存管理</strong>: 线程栈变量生命周期短暂，需用TLS或堆内存传递数据。</li>
</ul>
<hr>
<h2 id="6-implicit-threading">6. Implicit Threading</h2>
<h3 id="隐式线程技术">隐式线程技术</h3>
<ul>
<li><strong>目的</strong>: 减少显式线程管理的复杂性。</li>
<li><strong>实现方式</strong>:
<ul>
<li>Create a number of threads in a pool where they await work</li>
<li><strong>Thread Pools</strong>: 预创建线程池复用线程（如Windows API）。</li>
<li><strong>OpenMP/GCD</strong>: 编译器自动并行化代码。</li>
</ul>
</li>
</ul>
<h3 id="线程池优势-advantages">线程池优势 Advantages</h3>
<ul>
<li>Usually slightly faster to service a request with an existing thread than create a new thread</li>
<li>Allows the number of threads in the application(s) to be bound to the size of the pool</li>
<li>Separating task to be performed from mechanics of creating task allows different strategies for running task</li>
<li>i.e. Tasks could be scheduled to run periodically</li>
</ul>
<hr>
<h2 id="7-threading-issues">7. Threading Issues</h2>
<h3 id="关键问题-key-issues">关键问题 (Key Issues)</h3>
<ol>
<li>
<p><strong><code>fork()</code>与<code>exec()</code>的语义</strong>:</p>
<ul>
<li><code>fork()</code>可能有两种类型：子进程复制父进程所有线程，或仅复制父进程中调用了<code>fork()</code>的线程。</li>
<li><code>exec()</code>替换整个进程（包括所有线程）。</li>
</ul>
</li>
<li>
<p><strong>线程取消 (Thread Cancellation)</strong>:</p>
<ul>
<li><strong>异步取消 Asynchronous cancellation</strong>: 立即终止目标线程（可能导致资源泄漏）。</li>
<li><strong>延迟取消 Deferred cancellation</strong>: 线程定期检查取消点（更安全）。</li>
<li>仅当线程达到<strong>撤销点 cancellation point</strong>才会撤销</li>
</ul>
</li>
<li>
<p><strong>信号处理 (Signal Handling)</strong>:</p>
<ul>
<li>Signals are used in UNIX systems to notify a process that a particular event has occurred.</li>
<li>A signal handler is used to process signals
<ul>
<li>Signal is generated by particular event</li>
<li>Signal is delivered to a process</li>
<li>Signal is handled by one of two signal handlers:
<ul>
<li>default</li>
<li>user-defined</li>
</ul>
</li>
</ul>
</li>
<li>Every signal has <strong>default handler</strong> that kernel runs when handling signal
<ul>
<li><strong>User-defined signal handler</strong> can override default</li>
<li>For single-threaded, signal delivered to process</li>
</ul>
</li>
<li>信号可发送到特定线程或整个进程（如<code>SIGSEGV</code>）。</li>
</ul>
</li>
<li>
<p><strong>线程本地存储 (TLS)</strong>:</p>
<ul>
<li>同一进程的线程共享进程的数据。</li>
<li>线程本地存储：每个线程拥有独立数据（如全局计数器副本）。</li>
</ul>
</li>
<li>
<p><strong>调度器激活 (Scheduler Activations)</strong>:</p>
<ul>
<li>In M:M or Two-level model, how to maintain an appropriate number of kernel threads allocated to the application?
<ul>
<li>Communication</li>
</ul>
</li>
<li>Typically use an intermediate data structure between user and kernel threads: <strong>轻量级进程 lightweight process (LWP)</strong>
<ul>
<li>Appears to be a virtual processor on which process can schedule user thread to run</li>
<li>Each LWP attached to kernel thread</li>
</ul>
</li>
<li>Scheduler activations provide <strong>回调 upcalls</strong> - a communication mechanism from the kernel to the upcall handler in the thread library. (vs. downcalls)</li>
<li>This communication allows an application to maintain the correct number kernel threads</li>
<li>内核通过upcall通知 用户态线程库调整LWP数量。</li>
<li><img src="./pictures/4-6.png" alt="4-6"></li>
</ul>
</li>
</ol>
<hr>
<h2 id="课后练习-after-class-exercise">课后练习 (After Class Exercise)</h2>
<ul>
<li><strong>Q</strong>: What are two differences between user-level threads and kernel-level threads? Under what circumstances is one type better than the other?</li>
<li><strong>A</strong>:
<ol>
<li><strong>管理方</strong>: 用户线程由库管理，内核线程由OS管理。</li>
<li><strong>阻塞影响</strong>: 用户线程阻塞会阻塞整个进程，内核线程不会。</li>
</ol>
<ul>
<li><strong>适用场景</strong>: 用户线程适合高并发但无需多核的场景；内核线程适合需多核并行或避免阻塞的场景。</li>
</ul>
</li>
</ul>
</article><!-- 笔记工具条--><div class="note-tools"><button class="tool-btn" id="toggle-dark"><i class="fas fa-moon"></i><span>Dark Mode</span></button><button class="tool-btn" id="print-note"><i class="fas fa-print"></i><span>Print This Note</span></button></div></main><!-- 页脚--><footer class="footer"><div class="footer-content"><p>© 2025 WeiKnight. All Rights Reserved. </p><div class="footer-links"><a href="/notes/about" target="_blank">About</a><a href="/notes/terms" target="_blank">Terms of Use</a><a href="/notes/privacy" target="_blank">Privacy Policy</a></div></div></footer><script src="/js/note.js"></script><script>document.querySelectorAll('figure.highlight').forEach((figure) => {
  const langClass = Array.from(figure.classList).find(cls => cls !== 'highlight');
  if (!langClass) return;

  const langLabel = document.createElement('div');
  langLabel.textContent = langClass;
  langLabel.style.position = 'absolute';
  langLabel.style.top = '0';
  langLabel.style.right = '0';
  langLabel.style.padding = '0.2em 0.5em';
  langLabel.style.fontFamily = 'MapleMono-NF-CN';
  langLabel.style.fontSize = '0.8em';
  langLabel.style.borderRadius = '0 4px 0 4px';
  langLabel.style.zIndex = '1';

  // 设置初始样式（根据当前主题）
  updateLabelTheme(langLabel);

  figure.style.position = 'relative';
  figure.prepend(langLabel);
});

// 更新标签主题的函数
function updateLabelTheme(label) {
  const isDarkMode = document.body.getAttribute('data-theme') === 'dark';
  label.style.background = isDarkMode ? '#444' : '#eee';
  label.style.color = isDarkMode ? '#ddd' : '#333';
  //- console.log("更改了");
}

// 监听主题变化（仅更新标签）
new MutationObserver(() => {
  document.querySelectorAll('figure.highlight div').forEach(label => {
    updateLabelTheme(label);
    //- console.log("更改了2");
  });
}).observe(document.body, {
  attributes: true,
  attributeFilter: ['data-theme']
});</script></body></html>