<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>OS Memory List: KEY Concepts | WeiKnight's Personnal Blogs</title><link rel="icon" href="https://avatars.githubusercontent.com/WeiKnight0"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&amp;family=Roboto:wght@400;500;700&amp;display=swap"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"><link rel="stylesheet" href="/css/note.css"><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><!-- 导航栏--><header class="navbar"><div class="navbar-container"><div class="navbar-brand"><a class="avatar-link" target="_blank" rel="noopener" href="https://github.com/WeiKnight0"><img class="avatar" src="https://avatars.githubusercontent.com/WeiKnight0" alt="WeiKnight"></a><div class="navbar-info"><a class="name" target="_blank" rel="noopener" href="https://github.com/WeiKnight0">WeiKnight</a><div class="subject">Study Notes</div></div></div><div class="navbar-actions"><a class="nav-link" href="../" title="Return to Operating System"><i class="fas fa-arrow-left"></i><span>Return to Operating System</span></a><a class="nav-link" href="/"><i class="fas fa-home"></i><span>Return to Home Page</span></a></div></div></header><!-- 标题区域--><section class="title-section"><div class="title-container"><h1 class="chapter-title">OS Memory List: KEY Concepts</h1><div class="chapter-meta"><span class="chapter-date"><i class="far fa-calendar-alt"></i>2025-07-24</span><span class="chapter-lang"><p>Language: English</p></span></div></div></section><!-- 内容区域--><main class="content-section"><article class="chapter-content"><hr>
<h2 id="ch01">CH01</h2>
<ul>
<li>A program that acts as an intermediary between a user of a computer and the computer hardware.</li>
<li>OS is a <strong>resource allocator</strong>; OS is a <strong>control program</strong>.</li>
<li><strong>Virtualization</strong>; <strong>Concurrency</strong></li>
</ul>
<h2 id="ch02">CH02</h2>
<ul>
<li>API</li>
<li>System Call
<ul>
<li>Definition</li>
<li>parameters: Registers, Memory block, Stack</li>
<li>execute: Trap, trap-handler and return-from-trap</li>
<li>trap-handler</li>
<li>restore context: Kernel stack</li>
</ul>
</li>
<li>Type of System Calls
<ul>
<li><strong>Process Control</strong></li>
<li><strong>File Management</strong></li>
<li><strong>Device Management</strong></li>
<li><strong>Information Maintenance</strong></li>
<li><strong>Communication</strong></li>
<li><strong>Protection</strong></li>
</ul>
</li>
<li>OS Structure
<ul>
<li>Simple Structure
<ul>
<li>Monolithic</li>
</ul>
</li>
<li>More Complex</li>
<li>Layered</li>
<li>Microkernel</li>
<li>Moduless</li>
<li>Hybrid</li>
</ul>
</li>
</ul>
<h2 id="ch03">CH03</h2>
<ul>
<li>Process Memory Layout
<ul>
<li>Text: Program code</li>
<li>Data: Global variables</li>
<li>Heap: Dynamically allocated memory</li>
<li>Stack: Local variables, function parameters</li>
</ul>
</li>
<li>Process States
<ul>
<li>New</li>
<li>Ready</li>
<li>Running</li>
<li>Waiting/Blocked</li>
<li>Terminated</li>
<li><img src="./pictures/3-1.png" alt="Process State Diagram"></li>
</ul>
</li>
<li>PCB: Core data structure storing process state</li>
<li>Time Sharing OS: context switch
<ul>
<li><img src="./pictures/3-5.png" alt="TimeSharing"></li>
</ul>
</li>
<li>Scheduling Queues
<ul>
<li>Job Queue: All processes.</li>
<li>Ready Queue: Processes ready to execute.</li>
<li>Device Queue: Processes waiting for I/O.</li>
</ul>
</li>
<li>Scheduler
<ul>
<li>Long-term scheduler: Controls degree of multiprogramming</li>
<li>Short-term scheduler: selects which process should be executed next and allocates CPU</li>
<li>Medium-term scheduler: Swapping</li>
</ul>
</li>
<li>Process Termination Type
<ul>
<li>Normal</li>
<li>Abnormal</li>
<li>Zombie</li>
<li>Orphan</li>
</ul>
</li>
<li>IPC
<ul>
<li>Shared Memory</li>
<li>Message Passing</li>
</ul>
</li>
</ul>
<h2 id="ch04">CH04</h2>
<ul>
<li>Thread have its own:
<ul>
<li>Stack</li>
<li>Registers</li>
</ul>
</li>
<li>Threads share:
<ul>
<li>Code</li>
<li>Data</li>
<li>Files</li>
</ul>
</li>
<li>Multithreading Models
<ul>
<li>User Thread</li>
<li>Kernel Thread</li>
<li>Threading Models
<ul>
<li>M:O</li>
<li>O:O</li>
<li>M:M</li>
<li>Two Level Models</li>
</ul>
</li>
</ul>
</li>
<li><code>fork()</code> and <code>exec()</code></li>
<li>Thread Cancellation
<ul>
<li>Asynchronous cancellation</li>
<li>Deferred cancellation</li>
</ul>
</li>
<li>Signal Handling</li>
<li>TLS</li>
<li>Implicit Threading</li>
<li>Scheduler Activations
<ul>
<li>LWP</li>
<li>upcalls</li>
</ul>
</li>
</ul>
<h2 id="ch05">CH05</h2>
<ul>
<li>Schedule Timing
<ul>
<li>Running -&gt; Waiting: Non-Preemptive</li>
<li>Running -&gt; Ready</li>
<li>Waiting -&gt; Ready</li>
<li>Process terminates: Non-Preemptive</li>
</ul>
</li>
<li>Dispatcher
<ul>
<li>Dispatch latency</li>
</ul>
</li>
<li>Common Scheduling Criteria
<ul>
<li>CPU Utilization</li>
<li>Throughput
<ul>
<li>Number of processes completed per time unit</li>
</ul>
</li>
<li>Turnaround Time
<ul>
<li>Total time from <strong>submission</strong> to <strong>completion</strong></li>
</ul>
</li>
<li>Waiting Time
<ul>
<li>Time spent waiting in the <strong>ready queue</strong></li>
</ul>
</li>
<li>Response Time
<ul>
<li>Time from <strong>submission</strong> to <strong>first response</strong></li>
</ul>
</li>
</ul>
</li>
<li>Burst Time, Arrival Time</li>
<li>Simple Scheduling Algorithms
<ul>
<li>FCFS</li>
<li>SJF</li>
<li>Priority</li>
<li>Preemptive SJF</li>
<li>RR</li>
</ul>
</li>
<li>Multilevel Queue</li>
<li>Multilevel Feedback Queue (MLFQ)
<ul>
<li>Rules (x5)</li>
</ul>
</li>
<li>Multiple-Processor Scheduling
<ul>
<li>Asymmetric Multiprocessing - SQMS</li>
<li>Symmetric Multiprocessing - MQMS</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ch06">CH06</h2>
<ul>
<li>Requirements
<ul>
<li>Mutual Exclusion</li>
<li>Progress</li>
<li>Bounded Waiting</li>
</ul>
</li>
<li>Software Solution
<ul>
<li>Peterson's Solution</li>
<li>Bakery Algorithm</li>
</ul>
</li>
<li>Hardware Support
<ul>
<li>Interrupts</li>
<li>Test-and-Set</li>
<li>Compare-and-Swap</li>
<li>Fetch-and-Add</li>
</ul>
</li>
<li>Semaphore
<ul>
<li><code>wait()</code></li>
<li><code>signal()</code></li>
</ul>
</li>
<li>Monitor</li>
</ul>
<hr>
<h2 id="ch07">CH07</h2>
<ul>
<li>Deadlock Characterization
<ul>
<li><strong>Mutual Exclusion</strong></li>
<li><strong>Hold and Wait</strong></li>
<li><strong>No Preemption</strong></li>
<li><strong>Circular Wait</strong></li>
</ul>
</li>
<li>Methods for Handling Deadlocks
<ul>
<li><strong>Deadlock prevention</strong></li>
<li><strong>Deadlock avoidance</strong></li>
<li><strong>Deadlock detection</strong></li>
<li><strong>Recovery from deadlock</strong></li>
</ul>
</li>
<li><strong>Resource-Allocation-Graph Algorithm</strong>
<ul>
<li>Contd</li>
</ul>
</li>
<li><strong>Banker's Algorithm</strong>
<ul>
<li>Contd</li>
</ul>
</li>
<li>Detect Algorithm</li>
</ul>
<h2 id="ch08">CH08</h2>
<ul>
<li>Binding Time
<ul>
<li>Compile Time</li>
<li>Loading Time</li>
<li>Execution Time</li>
</ul>
</li>
<li>Dynamic Loading &amp; Linking</li>
<li>Eternal Fragmentation / Internal Fragmentation</li>
<li>Free Space Management
<ul>
<li>Best-fit</li>
<li>Worst-fit</li>
<li>First-fit</li>
<li>Next-fit</li>
</ul>
</li>
<li><strong>Calculation!</strong>
<ul>
<li>Virtual Address = VPN + offset</li>
<li>2^offset = Page Size</li>
<li>Max Page Count = 2^PFN
<ul>
<li>Memory Size = 2^PFN * Page Size</li>
</ul>
</li>
<li>PTE: What VPN Points to in Page Table = PFN + other bits
<ul>
<li>Use VPN to search PT to get PTE</li>
</ul>
</li>
</ul>
</li>
<li>EAT
<ul>
<li>Definition</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>ϵ</mi><mo stretchy="false">)</mo><mi>α</mi><mo>+</mo><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mi>ϵ</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">EAT = ([1] + \epsilon)\alpha + ([2] + 2\epsilon)(1 - \alpha)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϵ</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">ϵ</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
</li>
<li>Page Size Selection Considerations
<ul>
<li><strong>Internal Fragmentation: Small</strong></li>
<li><strong>Page Table Size/Page Faults: Large</strong></li>
<li><strong>IO Overhead: Large</strong></li>
<li><strong>Locality|Granularity Control: Small</strong></li>
<li><strong>TLB Reach|TLB Size: Large</strong></li>
</ul>
</li>
<li>Structure of the Page Table
<ul>
<li>Hybrid Approach: Paging and Segments</li>
<li><strong>Multi-Level Paging</strong></li>
<li>Hashed Page Tables</li>
<li>Clustered Page Tables</li>
<li>Inverted Page Tables</li>
</ul>
</li>
</ul>
<h2 id="ch09">CH09</h2>
<ul>
<li>Backing Store, <strong>Demand Paging</strong></li>
<li><strong>Page Fault Handling</strong></li>
<li>Basic Page Replacement</li>
<li>Algorithm
<ul>
<li>OPT</li>
<li>FIFO
<ul>
<li><strong>Bélády’s Anomaly</strong></li>
</ul>
</li>
<li>LRU</li>
<li>LRU Approximation Algorithms
<ul>
<li>Reference bit</li>
<li>Additional-Reference-Bits Algorithm</li>
<li>Second-chance algorithm</li>
</ul>
</li>
</ul>
</li>
<li>Allocation of Frames
<ul>
<li>Fixed Allocation
<ul>
<li>Equal Allocation</li>
<li>Proportional Allocation</li>
</ul>
</li>
<li>Priority Allocation</li>
<li>Global vs. Local Replacement</li>
<li>NUMA</li>
</ul>
</li>
<li>Thrashing
<ul>
<li>Excessive page faults → Low CPU utilization; OS responds by adding more processes, worsening thrashing</li>
<li>Locality Model</li>
<li>Working-Set Model
<ul>
<li>Working-Set Window</li>
<li>Working-Set Size</li>
</ul>
</li>
<li>PFF</li>
</ul>
</li>
<li>Copy-on-Write</li>
<li>Memory-Mapped Files</li>
</ul>
<h2 id="ch10">CH10</h2>
<ul>
<li>Moving-head Disk Mechanism
<ul>
<li>Track</li>
<li>Sector</li>
<li>Cylinder</li>
<li>Platter</li>
<li>Read-write head</li>
</ul>
</li>
<li>DIsk I/O Time
<ul>
<li>Seek time</li>
<li>Rotation delay</li>
<li>Transfer time</li>
</ul>
</li>
<li>Scheduling Algorithms
<ul>
<li>FCFS</li>
<li>SSTF</li>
<li>SCAN</li>
<li>C-SCAN</li>
<li>LOOK/C-LOOK</li>
<li>SPTF (ignored)</li>
</ul>
</li>
<li>RAID
<ul>
<li>RAID 0,1,1+0,0+1,4,5</li>
</ul>
</li>
</ul>
<h2 id="ch11">CH11</h2>
<ul>
<li>Hard Links / Soft Links</li>
</ul>
<h2 id="ch12">CH12</h2>
<ul>
<li>Allocation Method
<ul>
<li>FAT</li>
<li>Contiguous allocation</li>
<li>Linked allocation</li>
<li>Indexed allocation</li>
</ul>
</li>
<li>FCB/Inode</li>
</ul>
<h2 id="ch13">CH13</h2>
<ul>
<li>Pulling</li>
<li>Interrupts</li>
<li>DMA</li>
</ul>
</article><!-- 笔记工具条--><div class="note-tools"><button class="tool-btn" id="toggle-dark"><i class="fas fa-moon"></i><span>Dark Mode</span></button><button class="tool-btn" id="print-note"><i class="fas fa-print"></i><span>Print This Note</span></button></div></main><!-- 页脚--><footer class="footer"><div class="footer-content"><p>© 2025 WeiKnight. All Rights Reserved. </p><div class="footer-links"><a href="/notes/about" target="_blank">About</a><a href="/notes/terms" target="_blank">Terms of Use</a><a href="/notes/privacy" target="_blank">Privacy Policy</a></div></div></footer><script src="/js/note.js"></script><script>document.querySelectorAll('figure.highlight').forEach((figure) => {
  const langClass = Array.from(figure.classList).find(cls => cls !== 'highlight');
  if (!langClass) return;

  const langLabel = document.createElement('div');
  langLabel.textContent = langClass;
  langLabel.style.position = 'absolute';
  langLabel.style.top = '0';
  langLabel.style.right = '0';
  langLabel.style.padding = '0.2em 0.5em';
  langLabel.style.fontFamily = 'MapleMono-NF-CN';
  langLabel.style.fontSize = '0.8em';
  langLabel.style.borderRadius = '0 4px 0 4px';
  langLabel.style.zIndex = '1';

  // 设置初始样式（根据当前主题）
  updateLabelTheme(langLabel);

  figure.style.position = 'relative';
  figure.prepend(langLabel);
});

// 更新标签主题的函数
function updateLabelTheme(label) {
  const isDarkMode = document.body.getAttribute('data-theme') === 'dark';
  label.style.background = isDarkMode ? '#444' : '#eee';
  label.style.color = isDarkMode ? '#ddd' : '#333';
  //- console.log("更改了");
}

// 监听主题变化（仅更新标签）
new MutationObserver(() => {
  document.querySelectorAll('figure.highlight div').forEach(label => {
    updateLabelTheme(label);
    //- console.log("更改了2");
  });
}).observe(document.body, {
  attributes: true,
  attributeFilter: ['data-theme']
});</script></body></html>